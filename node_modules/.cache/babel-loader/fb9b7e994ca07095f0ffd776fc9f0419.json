{"ast":null,"code":"import Pool from '../../../../pool.js';\nimport Pen from './Pen.js';\nimport CONST from '../const.js';\nimport Clone from '../../../../utils/object/Clone.js';\nimport NOOP from '../../../../utils/object/NOOP.js';\nconst GetFastValue = Phaser.Utils.Objects.GetFastValue;\nconst NO_NEWLINE = CONST.NO_NEWLINE;\nconst WRAPPED_NEWLINE = CONST.WRAPPED_NEWLINE;\nvar PensPool = new Pool(); // default pens pool\n\nvar LinesPool = new Pool(); // default lines pool\n\nclass PenManager {\n  constructor(config) {\n    this.pens = []; // all pens\n\n    this.lines = []; // pens in lines [ [],[],[],.. ]\n\n    this.maxLinesWidth = undefined;\n    this.PensPool = GetFastValue(config, 'pensPool', PensPool);\n    this.LinesPool = GetFastValue(config, 'linesPool', LinesPool);\n    this.tagToText = GetFastValue(config, 'tagToText', NOOP);\n    this.tagToTextScope = GetFastValue(config, 'tagToTextScope', undefined);\n  }\n\n  destroy() {\n    this.freePens();\n    this.tagToText = undefined;\n    this.tagToTextScope = undefined;\n  }\n\n  freePens() {\n    for (var i = 0, len = this.lines.length; i < len; i++) this.lines[i].length = 0;\n\n    this.PensPool.pushMultiple(this.pens);\n    this.LinesPool.pushMultiple(this.lines);\n    this.maxLinesWidth = undefined;\n  }\n\n  addTextPen(text, x, y, width, prop, newLineMode) {\n    var pen = this.PensPool.pop();\n\n    if (pen == null) {\n      pen = new Pen();\n    }\n\n    PEN_CONFIG.text = text;\n    PEN_CONFIG.x = x;\n    PEN_CONFIG.y = y;\n    PEN_CONFIG.width = width;\n    PEN_CONFIG.prop = prop;\n    PEN_CONFIG.newLineMode = newLineMode;\n    pen.resetFromJSON(PEN_CONFIG);\n    this.addPen(pen);\n    return this;\n  }\n\n  addImagePen(x, y, width, prop) {\n    this.addTextPen('', x, y, width, prop, NO_NEWLINE);\n    return this;\n  }\n\n  addNewLinePen() {\n    var previousPen = this.lastPen;\n    var x = previousPen ? previousPen.lastX : 0;\n    var y = previousPen ? previousPen.y : 0;\n    var prop = previousPen ? Clone(previousPen.prop) : null;\n    this.addTextPen('', x, y, 0, prop, WRAPPED_NEWLINE);\n    return this;\n  }\n\n  addPen(pen) {\n    var previousPen = this.lastPen;\n\n    if (previousPen == null) {\n      pen.startIndex = 0;\n    } else {\n      pen.startIndex = previousPen.endIndex;\n    }\n\n    this.pens.push(pen); // maintan lines\n\n    var line = this.lastLine;\n\n    if (line == null) {\n      line = this.LinesPool.pop() || [];\n      this.lines.push(line);\n    }\n\n    line.push(pen); // new line, add an empty line\n\n    if (pen.newLineMode !== NO_NEWLINE) {\n      line = this.LinesPool.pop() || [];\n      this.lines.push(line);\n    }\n\n    this.maxLinesWidth = undefined;\n  }\n\n  clone(targetPenManager) {\n    if (targetPenManager == null) targetPenManager = new PenManager();\n    targetPenManager.freePens();\n\n    for (var li = 0, llen = this.lines.length; li < llen; li++) {\n      var pens = this.lines[li];\n\n      for (var pi = 0, plen = pens.length; pi < plen; pi++) {\n        var pen = pens[pi];\n        targetPenManager.addPen(pen.text, pen.x, pen.y, pen.width, Clone(pen.prop), pen.newLineMode);\n      }\n    }\n\n    return targetPenManager;\n  }\n\n  get lastPen() {\n    return this.pens[this.pens.length - 1];\n  }\n\n  get lastLine() {\n    return this.lines[this.lines.length - 1];\n  }\n\n  getLineStartIndex(i) {\n    if (i >= this.lines.length) {\n      return this.getLineEndIndex(i);\n    } else {\n      var line = this.lines[i];\n      return line && line[0] ? line[0].startIndex : 0;\n    }\n  }\n\n  getLineEndIndex(i) {\n    if (i >= this.lines.length) {\n      i = this.lines.length - 1;\n    }\n\n    var li,\n        hasLastPen = false,\n        line;\n\n    for (li = i; li >= 0; li--) {\n      line = this.lines[li];\n      hasLastPen = line != null && line.length > 0;\n\n      if (hasLastPen) {\n        break;\n      }\n    }\n\n    if (!hasLastPen) {\n      return 0;\n    }\n\n    var lastPen = line[line.length - 1];\n    return lastPen.endIndex;\n  }\n\n  getLineWidth(i) {\n    var line = this.lines[i];\n\n    if (!line) {\n      return 0;\n    }\n\n    var lastPen = line[line.length - 1];\n\n    if (lastPen == null) {\n      return 0;\n    }\n\n    var lineWidth = lastPen.lastX; // start from 0\n\n    return lineWidth;\n  }\n\n  getMaxLineWidth() {\n    if (this.maxLinesWidth !== undefined) {\n      return this.maxLinesWidth;\n    }\n\n    var w,\n        maxW = 0;\n\n    for (var i = 0, len = this.lines.length; i < len; i++) {\n      w = this.getLineWidth(i);\n\n      if (w > maxW) {\n        maxW = w;\n      }\n    }\n\n    this.maxLinesWidth = maxW;\n    return maxW;\n  }\n\n  getLineWidths() {\n    var result = [];\n\n    for (var i = 0, len = this.lines.length; i < len; i++) {\n      result.push(this.getLineWidth(i));\n    }\n\n    return result;\n  }\n\n  get linesCount() {\n    return this.lines.length;\n  }\n\n  get plainText() {\n    var txt = \"\",\n        pens = this.pens;\n\n    for (var i = 0, len = pens.length; i < len; i++) {\n      txt += pens[i].plainText;\n    }\n\n    return txt;\n  }\n\n  get rawTextLength() {\n    var l = 0,\n        pens = this.pens;\n\n    for (var i = 0, len = this.pens.length; i < len; i++) {\n      l += pens[i].rawTextLength;\n    }\n\n    return l;\n  }\n\n  getSliceTagText(start, end, wrap) {\n    if (start === undefined) {\n      start = 0;\n    }\n\n    if (end === undefined) {\n      var lastPen = this.lastPen;\n\n      if (lastPen == null) {\n        return \"\";\n      }\n\n      end = lastPen.endIndex;\n    }\n\n    if (wrap === undefined) {\n      wrap = false;\n    }\n\n    var txt = \"\",\n        formatTxt,\n        pen,\n        penTxt,\n        penStartIdx,\n        penEndIdx,\n        isInRange;\n    var currentProp, previousProp;\n\n    for (var i = 0, len = this.pens.length; i < len; i++) {\n      pen = this.pens[i];\n      penEndIdx = pen.endIndex;\n\n      if (penEndIdx <= start) {\n        continue;\n      }\n\n      pen = this.pens[i];\n      penTxt = !wrap ? pen.plainText : pen.wrapText;\n      currentProp = pen.prop;\n      penStartIdx = pen.startIndex;\n      isInRange = penStartIdx >= start && penEndIdx <= end;\n\n      if (!isInRange) {\n        penTxt = penTxt.substring(start - penStartIdx, end - penStartIdx);\n      }\n\n      if (this.tagToTextScope) {\n        txt += this.tagToText.call(this.tagToTextScope, penTxt, currentProp, previousProp);\n      } else {\n        txt += this.tagToText(penTxt, currentProp, previousProp);\n      }\n\n      previousProp = currentProp;\n\n      if (penEndIdx >= end) {\n        break;\n      }\n    }\n\n    return txt;\n  }\n\n}\n\n;\nvar PEN_CONFIG = {};\nexport default PenManager;","map":{"version":3,"sources":["/home/jon/code/Projects/Soulys/frontend/node_modules/phaser3-rex-plugins/plugins/gameobjects/text/textbase/penmanger/PenManager.js"],"names":["Pool","Pen","CONST","Clone","NOOP","GetFastValue","Phaser","Utils","Objects","NO_NEWLINE","WRAPPED_NEWLINE","PensPool","LinesPool","PenManager","constructor","config","pens","lines","maxLinesWidth","undefined","tagToText","tagToTextScope","destroy","freePens","i","len","length","pushMultiple","addTextPen","text","x","y","width","prop","newLineMode","pen","pop","PEN_CONFIG","resetFromJSON","addPen","addImagePen","addNewLinePen","previousPen","lastPen","lastX","startIndex","endIndex","push","line","lastLine","clone","targetPenManager","li","llen","pi","plen","getLineStartIndex","getLineEndIndex","hasLastPen","getLineWidth","lineWidth","getMaxLineWidth","w","maxW","getLineWidths","result","linesCount","plainText","txt","rawTextLength","l","getSliceTagText","start","end","wrap","formatTxt","penTxt","penStartIdx","penEndIdx","isInRange","currentProp","previousProp","wrapText","substring","call"],"mappings":"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","sourcesContent":["import Pool from '../../../../pool.js';\r\nimport Pen from './Pen.js';\r\nimport CONST from '../const.js';\r\nimport Clone from '../../../../utils/object/Clone.js';\r\nimport NOOP from '../../../../utils/object/NOOP.js';\r\n\r\nconst GetFastValue = Phaser.Utils.Objects.GetFastValue;\r\nconst NO_NEWLINE = CONST.NO_NEWLINE;\r\nconst WRAPPED_NEWLINE = CONST.WRAPPED_NEWLINE;\r\n\r\nvar PensPool = new Pool(); // default pens pool\r\nvar LinesPool = new Pool(); // default lines pool\r\nclass PenManager {\r\n    constructor(config) {\r\n        this.pens = []; // all pens\r\n        this.lines = []; // pens in lines [ [],[],[],.. ]\r\n        this.maxLinesWidth = undefined;\r\n\r\n        this.PensPool = GetFastValue(config, 'pensPool', PensPool);\r\n        this.LinesPool = GetFastValue(config, 'linesPool', LinesPool);\r\n        this.tagToText = GetFastValue(config, 'tagToText', NOOP);\r\n        this.tagToTextScope = GetFastValue(config, 'tagToTextScope', undefined);\r\n    }\r\n\r\n    destroy() {\r\n        this.freePens();\r\n        this.tagToText = undefined;\r\n        this.tagToTextScope = undefined;\r\n    }\r\n\r\n    freePens() {\r\n        for (var i = 0, len = this.lines.length; i < len; i++)\r\n            this.lines[i].length = 0;\r\n\r\n        this.PensPool.pushMultiple(this.pens);\r\n        this.LinesPool.pushMultiple(this.lines);\r\n        this.maxLinesWidth = undefined;\r\n    }\r\n\r\n    addTextPen(text, x, y, width, prop, newLineMode) {\r\n        var pen = this.PensPool.pop();\r\n        if (pen == null) {\r\n            pen = new Pen();\r\n        }\r\n        PEN_CONFIG.text = text;\r\n        PEN_CONFIG.x = x;\r\n        PEN_CONFIG.y = y;\r\n        PEN_CONFIG.width = width;\r\n        PEN_CONFIG.prop = prop;\r\n        PEN_CONFIG.newLineMode = newLineMode;\r\n        pen.resetFromJSON(PEN_CONFIG);\r\n        this.addPen(pen);\r\n        return this;\r\n    }\r\n\r\n    addImagePen(x, y, width, prop) {\r\n        this.addTextPen('', x, y, width, prop, NO_NEWLINE);\r\n        return this;\r\n    }\r\n\r\n    addNewLinePen() {\r\n        var previousPen = this.lastPen;\r\n        var x = (previousPen) ? previousPen.lastX : 0;\r\n        var y = (previousPen) ? previousPen.y : 0;\r\n        var prop = (previousPen) ? Clone(previousPen.prop) : null;\r\n        this.addTextPen('', x, y, 0, prop, WRAPPED_NEWLINE);\r\n        return this;\r\n    }\r\n\r\n    addPen(pen) {\r\n        var previousPen = this.lastPen;\r\n        if (previousPen == null) {\r\n            pen.startIndex = 0;\r\n        } else {\r\n            pen.startIndex = previousPen.endIndex;\r\n        }\r\n        this.pens.push(pen);\r\n\r\n        // maintan lines\r\n        var line = this.lastLine;\r\n        if (line == null) {\r\n            line = this.LinesPool.pop() || [];\r\n            this.lines.push(line);\r\n        }\r\n        line.push(pen);\r\n\r\n        // new line, add an empty line\r\n        if (pen.newLineMode !== NO_NEWLINE) {\r\n            line = this.LinesPool.pop() || [];\r\n            this.lines.push(line);\r\n        }\r\n        this.maxLinesWidth = undefined;\r\n    }\r\n\r\n    clone(targetPenManager) {\r\n        if (targetPenManager == null)\r\n            targetPenManager = new PenManager();\r\n\r\n        targetPenManager.freePens();\r\n\r\n        for (var li = 0, llen = this.lines.length; li < llen; li++) {\r\n            var pens = this.lines[li];\r\n            for (var pi = 0, plen = pens.length; pi < plen; pi++) {\r\n                var pen = pens[pi];\r\n                targetPenManager.addPen(\r\n                    pen.text,\r\n                    pen.x,\r\n                    pen.y,\r\n                    pen.width,\r\n                    Clone(pen.prop),\r\n                    pen.newLineMode\r\n                );\r\n            }\r\n        }\r\n\r\n        return targetPenManager;\r\n    }\r\n\r\n    get lastPen() {\r\n        return this.pens[this.pens.length - 1];\r\n    }\r\n\r\n    get lastLine() {\r\n        return this.lines[this.lines.length - 1];\r\n    }\r\n\r\n    getLineStartIndex(i) {\r\n        if (i >= this.lines.length) {\r\n            return this.getLineEndIndex(i);\r\n        } else {\r\n            var line = this.lines[i];\r\n            return (line && line[0]) ? line[0].startIndex : 0;\r\n        }\r\n    }\r\n\r\n    getLineEndIndex(i) {\r\n        if (i >= this.lines.length) {\r\n            i = this.lines.length - 1;\r\n        }\r\n        var li, hasLastPen = false,\r\n            line;\r\n        for (li = i; li >= 0; li--) {\r\n            line = this.lines[li];\r\n            hasLastPen = (line != null) && (line.length > 0);\r\n            if (hasLastPen) {\r\n                break;\r\n            }\r\n        }\r\n        if (!hasLastPen) {\r\n            return 0;\r\n        }\r\n\r\n        var lastPen = line[line.length - 1];\r\n        return lastPen.endIndex;\r\n    }\r\n\r\n    getLineWidth(i) {\r\n        var line = this.lines[i];\r\n        if (!line) {\r\n            return 0;\r\n        }\r\n\r\n        var lastPen = line[line.length - 1];\r\n        if (lastPen == null) {\r\n            return 0;\r\n        }\r\n\r\n        var lineWidth = lastPen.lastX; // start from 0\r\n        return lineWidth;\r\n    }\r\n\r\n    getMaxLineWidth() {\r\n        if (this.maxLinesWidth !== undefined) {\r\n            return this.maxLinesWidth;\r\n        }\r\n        var w, maxW = 0;\r\n        for (var i = 0, len = this.lines.length; i < len; i++) {\r\n            w = this.getLineWidth(i);\r\n            if (w > maxW) {\r\n                maxW = w;\r\n            }\r\n        }\r\n        this.maxLinesWidth = maxW;\r\n        return maxW;\r\n    }\r\n\r\n    getLineWidths() {\r\n        var result = [];\r\n        for (var i = 0, len = this.lines.length; i < len; i++) {\r\n            result.push(this.getLineWidth(i));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    get linesCount() {\r\n        return this.lines.length;\r\n    }\r\n\r\n    get plainText() {\r\n        var txt = \"\",\r\n            pens = this.pens;\r\n        for (var i = 0, len = pens.length; i < len; i++) {\r\n            txt += pens[i].plainText;\r\n        }\r\n\r\n        return txt;\r\n    }\r\n\r\n    get rawTextLength() {\r\n        var l = 0,\r\n            pens = this.pens;\r\n        for (var i = 0, len = this.pens.length; i < len; i++) {\r\n            l += pens[i].rawTextLength;\r\n        }\r\n\r\n        return l;\r\n    }\r\n\r\n    getSliceTagText(start, end, wrap) {\r\n        if (start === undefined) {\r\n            start = 0;\r\n        }\r\n        if (end === undefined) {\r\n            var lastPen = this.lastPen;\r\n            if (lastPen == null) {\r\n                return \"\";\r\n            }\r\n\r\n            end = lastPen.endIndex;\r\n        }\r\n        if (wrap === undefined) {\r\n            wrap = false;\r\n        }\r\n\r\n        var txt = \"\",\r\n            formatTxt,\r\n            pen, penTxt, penStartIdx, penEndIdx, isInRange;\r\n        var currentProp, previousProp;\r\n        for (var i = 0, len = this.pens.length; i < len; i++) {\r\n            pen = this.pens[i];\r\n            penEndIdx = pen.endIndex;\r\n            if (penEndIdx <= start) {\r\n                continue;\r\n            }\r\n            pen = this.pens[i];\r\n            penTxt = (!wrap) ? pen.plainText : pen.wrapText;\r\n            currentProp = pen.prop;\r\n            penStartIdx = pen.startIndex;\r\n\r\n            isInRange = (penStartIdx >= start) && (penEndIdx <= end);\r\n            if (!isInRange) {\r\n                penTxt = penTxt.substring(start - penStartIdx, end - penStartIdx);\r\n            }\r\n\r\n            if (this.tagToTextScope) {\r\n                txt += this.tagToText.call(this.tagToTextScope, penTxt, currentProp, previousProp);\r\n            } else {\r\n                txt += this.tagToText(penTxt, currentProp, previousProp);\r\n            }\r\n\r\n            previousProp = currentProp;\r\n            if (penEndIdx >= end) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return txt;\r\n    }\r\n};\r\n\r\nvar PEN_CONFIG = {};\r\n\r\nexport default PenManager;"]},"metadata":{},"sourceType":"module"}