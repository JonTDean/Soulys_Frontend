{"ast":null,"code":"import Pool from '../../../../pool.js';\nimport CONST from '../const.js';\nconst NO_NEWLINE = CONST.NO_NEWLINE;\nconst RAW_NEWLINE = CONST.RAW_NEWLINE;\nconst WRAPPED_NEWLINE = CONST.WRAPPED_NEWLINE;\nconst NO_WRAP = CONST.NO_WRAP;\nconst WORD_WRAP = CONST.WORD_WRAP;\nconst CHAR_WRAP = CONST.CHAR_WRAP;\nconst splitRegExp = CONST.SPLITREGEXP;\nvar WRAP_RESULT = [];\n\nvar WrapText = function (text, getTextWidth, wrapMode, wrapWidth, offset) {\n  if (wrapWidth <= 0) {\n    wrapMode = NO_WRAP;\n  }\n\n  var retLines = WRAP_RESULT;\n  LinesPool.pushMultiple(retLines);\n\n  if (!text || !text.length) {\n    return retLines;\n  }\n\n  var lines = text.split(splitRegExp),\n      line,\n      remainWidth,\n      isLaseLine,\n      newLineMode;\n\n  for (var i = 0, linesLen = lines.length; i < linesLen; i++) {\n    line = lines[i];\n    newLineMode = i === linesLen - 1 ? NO_NEWLINE : RAW_NEWLINE;\n\n    if (wrapMode === NO_WRAP) {\n      var textWidth = getTextWidth(line);\n      retLines.push(LinesPool.newline(line, textWidth, newLineMode));\n      continue;\n    } else {\n      if (i === 0) {\n        remainWidth = wrapWidth - offset;\n      } else {\n        remainWidth = wrapWidth;\n      }\n    } // short string testing\n\n\n    if (line.length <= 100) {\n      var textWidth = getTextWidth(line);\n\n      if (textWidth <= remainWidth) {\n        retLines.push(LinesPool.newline(line, textWidth, newLineMode));\n        continue;\n      }\n    } // character mode\n\n\n    var tokenArray;\n\n    if (wrapMode === WORD_WRAP) {\n      // word mode\n      tokenArray = line.split(' ');\n    } else {\n      tokenArray = line;\n    }\n\n    var token;\n    var curLineText = '',\n        lineText = '',\n        currLineWidth,\n        lineWidth = 0;\n\n    for (var j = 0, tokenLen = tokenArray.length; j < tokenLen; j++) {\n      token = tokenArray[j];\n\n      if (wrapMode === WORD_WRAP) {\n        curLineText += token;\n\n        if (j < tokenLen - 1) {\n          curLineText += ' ';\n        }\n      } else {\n        curLineText += token;\n      }\n\n      currLineWidth = getTextWidth(curLineText);\n\n      if (currLineWidth > remainWidth) {\n        // new line\n        if (j === 0) {\n          retLines.push(LinesPool.newline('', 0, WRAPPED_NEWLINE));\n        } else {\n          retLines.push(LinesPool.newline(lineText, lineWidth, WRAPPED_NEWLINE));\n          curLineText = token;\n\n          if (wrapMode === WORD_WRAP) {\n            if (j < tokenLen - 1) {\n              curLineText += ' ';\n            }\n          }\n\n          currLineWidth = getTextWidth(curLineText);\n        }\n\n        remainWidth = wrapWidth;\n      }\n\n      lineText = curLineText;\n      lineWidth = currLineWidth;\n    } // for token in tokenArray\n    // flush remain text\n\n\n    retLines.push(LinesPool.newline(lineText, lineWidth, newLineMode));\n  } // for each line in lines\n\n\n  return retLines;\n};\n\nvar LinesPool = new Pool();\n\nLinesPool.newline = function (text, width, newLineMode) {\n  var l = this.pop();\n\n  if (l === null) {\n    l = {};\n  }\n\n  l.text = text;\n  l.width = width;\n  l.newLineMode = newLineMode;\n  return l;\n};\n\nexport default WrapText;","map":{"version":3,"sources":["/home/jon/code/Projects/Soulys/frontend/node_modules/phaser3-rex-plugins/plugins/gameobjects/text/textbase/canvastext/WrapText.js"],"names":["Pool","CONST","NO_NEWLINE","RAW_NEWLINE","WRAPPED_NEWLINE","NO_WRAP","WORD_WRAP","CHAR_WRAP","splitRegExp","SPLITREGEXP","WRAP_RESULT","WrapText","text","getTextWidth","wrapMode","wrapWidth","offset","retLines","LinesPool","pushMultiple","length","lines","split","line","remainWidth","isLaseLine","newLineMode","i","linesLen","textWidth","push","newline","tokenArray","token","curLineText","lineText","currLineWidth","lineWidth","j","tokenLen","width","l","pop"],"mappings":"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","sourcesContent":["import Pool from '../../../../pool.js';\r\nimport CONST from '../const.js';\r\n\r\nconst NO_NEWLINE = CONST.NO_NEWLINE;\r\nconst RAW_NEWLINE = CONST.RAW_NEWLINE;\r\nconst WRAPPED_NEWLINE = CONST.WRAPPED_NEWLINE;\r\nconst NO_WRAP = CONST.NO_WRAP;\r\nconst WORD_WRAP = CONST.WORD_WRAP;\r\nconst CHAR_WRAP = CONST.CHAR_WRAP;\r\nconst splitRegExp = CONST.SPLITREGEXP;\r\n\r\nvar WRAP_RESULT = [];\r\nvar WrapText = function (text, getTextWidth, wrapMode, wrapWidth, offset) {\r\n    if (wrapWidth <= 0) {\r\n        wrapMode = NO_WRAP;\r\n    }\r\n\r\n    var retLines = WRAP_RESULT;\r\n    LinesPool.pushMultiple(retLines);\r\n\r\n    if (!text || !text.length) {\r\n        return retLines;\r\n    }\r\n\r\n    var lines = text.split(splitRegExp),\r\n        line, remainWidth, isLaseLine, newLineMode;\r\n    for (var i = 0, linesLen = lines.length; i < linesLen; i++) {\r\n        line = lines[i];\r\n        newLineMode = (i === (linesLen - 1)) ? NO_NEWLINE : RAW_NEWLINE;\r\n\r\n        if (wrapMode === NO_WRAP) {\r\n            var textWidth = getTextWidth(line);\r\n            retLines.push(LinesPool.newline(line, textWidth, newLineMode));\r\n            continue;\r\n        } else {\r\n            if (i === 0) {\r\n                remainWidth = wrapWidth - offset;\r\n            } else {\r\n                remainWidth = wrapWidth;\r\n            }\r\n        }\r\n\r\n        // short string testing\r\n        if (line.length <= 100) {\r\n            var textWidth = getTextWidth(line);\r\n            if (textWidth <= remainWidth) {\r\n                retLines.push(LinesPool.newline(line, textWidth, newLineMode));\r\n                continue;\r\n            }\r\n        }\r\n\r\n        // character mode\r\n        var tokenArray;\r\n        if (wrapMode === WORD_WRAP) {\r\n            // word mode\r\n            tokenArray = line.split(' ');\r\n        } else {\r\n            tokenArray = line;\r\n        }\r\n        var token;\r\n        var curLineText = '',\r\n            lineText = '',\r\n            currLineWidth, lineWidth = 0;\r\n        for (var j = 0, tokenLen = tokenArray.length; j < tokenLen; j++) {\r\n            token = tokenArray[j];\r\n\r\n            if (wrapMode === WORD_WRAP) {\r\n                curLineText += token;\r\n\r\n                if (j < (tokenLen - 1)) {\r\n                    curLineText += ' ';\r\n                }\r\n            } else {\r\n                curLineText += token;\r\n            }\r\n\r\n            currLineWidth = getTextWidth(curLineText);\r\n            if (currLineWidth > remainWidth) {\r\n                // new line\r\n                if (j === 0) {\r\n                    retLines.push(LinesPool.newline('', 0, WRAPPED_NEWLINE));\r\n                } else {\r\n                    retLines.push(LinesPool.newline(lineText, lineWidth, WRAPPED_NEWLINE));\r\n                    curLineText = token;\r\n                    if (wrapMode === WORD_WRAP) {\r\n                        if (j < (tokenLen - 1)) {\r\n                            curLineText += ' ';\r\n                        }\r\n                    }\r\n                    currLineWidth = getTextWidth(curLineText);\r\n                }\r\n\r\n                remainWidth = wrapWidth;\r\n            }\r\n\r\n            lineText = curLineText;\r\n            lineWidth = currLineWidth;\r\n        } // for token in tokenArray\r\n\r\n        // flush remain text\r\n        retLines.push(LinesPool.newline(lineText, lineWidth, newLineMode));\r\n\r\n    } // for each line in lines\r\n\r\n    return retLines;\r\n};\r\n\r\nvar LinesPool = new Pool();\r\nLinesPool.newline = function (text, width, newLineMode) {\r\n    var l = this.pop();\r\n    if (l === null) {\r\n        l = {};\r\n    }\r\n    l.text = text;\r\n    l.width = width;\r\n    l.newLineMode = newLineMode;\r\n    return l;\r\n};\r\n\r\nexport default WrapText;"]},"metadata":{},"sourceType":"module"}