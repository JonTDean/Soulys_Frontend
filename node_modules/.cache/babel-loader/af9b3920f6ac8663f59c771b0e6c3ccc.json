{"ast":null,"code":"export default {\n  updateTexture(callback, scope) {\n    if (callback) {\n      if (scope) {\n        callback.call(scope, this.canvas, this.context);\n      } else {\n        callback(this.canvas, this.context);\n      }\n    }\n\n    if (this.canvas.width !== this.frame.width || this.canvas.height !== this.frame.height) {\n      this.frame.setSize(this.canvas.width, this.canvas.height);\n    }\n\n    if (this.renderer.gl) {\n      this.frame.source.glTexture = this.renderer.canvasToTexture(this.canvas, this.frame.source.glTexture, true);\n      this.frame.glTexture = this.frame.source.glTexture;\n    }\n\n    this.dirty = false;\n    var input = this.input;\n\n    if (input && !input.customHitArea) {\n      input.hitArea.width = this.width;\n      input.hitArea.height = this.height;\n    }\n\n    return this;\n  },\n\n  generateTexture(key, x, y, width, height) {\n    var srcCanvas = this.canvas;\n    var sys = this.scene.sys;\n    var renderer = sys.game.renderer;\n    var texture;\n\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (width === undefined) {\n      width = srcCanvas.width;\n    } else {\n      width *= this.resolution;\n    }\n\n    if (height === undefined) {\n      height = srcCanvas.height;\n    } else {\n      height *= this.resolution;\n    }\n\n    if (sys.textures.exists(key)) {\n      texture = sys.textures.get(key);\n    } else {\n      texture = sys.textures.createCanvas(key, width, height);\n    }\n\n    var destCanvas = texture.getSourceImage();\n\n    if (destCanvas.width !== width) {\n      destCanvas.width = width;\n    }\n\n    if (destCanvas.height !== height) {\n      destCanvas.height = height;\n    }\n\n    var destCtx = destCanvas.getContext('2d');\n    destCtx.clearRect(0, 0, width, height);\n    destCtx.drawImage(srcCanvas, x, y, width, height);\n\n    if (renderer.gl && texture) {\n      renderer.canvasToTexture(destCanvas, texture.source[0].glTexture, true, 0);\n    }\n\n    return this;\n  },\n\n  loadTexture(key, frame) {\n    var textureFrame = this.scene.textures.getFrame(key, frame);\n\n    if (!textureFrame) {\n      return this;\n    }\n\n    if (this.width !== textureFrame.cutWidth || this.height !== textureFrame.cutHeight) {\n      this.resize(textureFrame.cutWidth, textureFrame.cutHeight);\n    } else {\n      this.clear();\n    }\n\n    this.context.drawImage(textureFrame.source.image, textureFrame.cutX, textureFrame.cutY, textureFrame.cutWidth, textureFrame.cutHeight, 0, 0, this.canvas.width, this.canvas.height);\n    this.dirty = true;\n    return this;\n  }\n\n};","map":{"version":3,"sources":["/home/jon/code/Projects/Soulys/frontend/node_modules/phaser3-rex-plugins/plugins/gameobjects/canvas/TextureMethods.js"],"names":["updateTexture","callback","scope","call","canvas","context","width","frame","height","setSize","renderer","gl","source","glTexture","canvasToTexture","dirty","input","customHitArea","hitArea","generateTexture","key","x","y","srcCanvas","sys","scene","game","texture","undefined","resolution","textures","exists","get","createCanvas","destCanvas","getSourceImage","destCtx","getContext","clearRect","drawImage","loadTexture","textureFrame","getFrame","cutWidth","cutHeight","resize","clear","image","cutX","cutY"],"mappings":"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","sourcesContent":["export default {\r\n    updateTexture(callback, scope) {\r\n        if (callback) {\r\n            if (scope) {\r\n                callback.call(scope, this.canvas, this.context);\r\n            } else {\r\n                callback(this.canvas, this.context);\r\n            }\r\n        }\r\n\r\n        if ((this.canvas.width !== this.frame.width) || (this.canvas.height !== this.frame.height)) {\r\n            this.frame.setSize(this.canvas.width, this.canvas.height);\r\n        }\r\n        if (this.renderer.gl) {\r\n            this.frame.source.glTexture = this.renderer.canvasToTexture(this.canvas, this.frame.source.glTexture, true);\r\n            this.frame.glTexture = this.frame.source.glTexture;\r\n        }\r\n        this.dirty = false;\r\n\r\n        var input = this.input;\r\n        if (input && !input.customHitArea) {\r\n            input.hitArea.width = this.width;\r\n            input.hitArea.height = this.height;\r\n        }\r\n        return this;\r\n    },\r\n\r\n    generateTexture(key, x, y, width, height) {\r\n        var srcCanvas = this.canvas;\r\n        var sys = this.scene.sys;\r\n        var renderer = sys.game.renderer;\r\n        var texture;\r\n\r\n        if (x === undefined) {\r\n            x = 0;\r\n        }\r\n\r\n        if (y === undefined) {\r\n            y = 0;\r\n        }\r\n\r\n        if (width === undefined) {\r\n            width = srcCanvas.width;\r\n        } else {\r\n            width *= this.resolution;\r\n        }\r\n\r\n        if (height === undefined) {\r\n            height = srcCanvas.height;\r\n        } else {\r\n            height *= this.resolution;\r\n        }\r\n\r\n\r\n        if (sys.textures.exists(key)) {\r\n            texture = sys.textures.get(key);\r\n        } else {\r\n            texture = sys.textures.createCanvas(key, width, height);\r\n        }\r\n\r\n        var destCanvas = texture.getSourceImage();\r\n        if (destCanvas.width !== width) {\r\n            destCanvas.width = width;\r\n        }\r\n        if (destCanvas.height !== height) {\r\n            destCanvas.height = height;\r\n        }\r\n\r\n        var destCtx = destCanvas.getContext('2d');\r\n        destCtx.clearRect(0, 0, width, height);\r\n        destCtx.drawImage(srcCanvas, x, y, width, height);\r\n        if (renderer.gl && texture) {\r\n            renderer.canvasToTexture(destCanvas, texture.source[0].glTexture, true, 0);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    loadTexture(key, frame) {\r\n        var textureFrame = this.scene.textures.getFrame(key, frame);\r\n        if (!textureFrame) {\r\n            return this;\r\n        }\r\n\r\n        if ((this.width !== textureFrame.cutWidth) || (this.height !== textureFrame.cutHeight)) {\r\n            this.resize(textureFrame.cutWidth, textureFrame.cutHeight);\r\n        } else {\r\n            this.clear();\r\n        }\r\n        this.context.drawImage(textureFrame.source.image,\r\n            textureFrame.cutX, textureFrame.cutY, textureFrame.cutWidth, textureFrame.cutHeight,\r\n            0, 0, this.canvas.width, this.canvas.height);\r\n        this.dirty = true;\r\n        return this;\r\n    }\r\n\r\n}"]},"metadata":{},"sourceType":"module"}