{"ast":null,"code":"import OnePointerTracer from \"../onepointertracer/OnePointerTracer.js\";\nimport FSM from '../../../fsm.js';\nconst GetValue = Phaser.Utils.Objects.GetValue;\nconst DistanceBetween = Phaser.Math.Distance.Between;\n\nclass Tap extends OnePointerTracer {\n  constructor(gameObject, config) {\n    super(gameObject, config);\n    var self = this;\n    var stateConfig = {\n      states: {\n        IDLE: {\n          enter: function () {\n            self.stop();\n            self.tapsCount = 0;\n            self.x = 0;\n            self.y = 0;\n            self.worldX = 0;\n            self.worldY = 0;\n          },\n          exit: function () {\n            var pointer = self.lastPointer;\n            self.x = pointer.x;\n            self.y = pointer.y;\n            self.worldX = pointer.worldX;\n            self.worldY = pointer.worldY;\n          }\n        },\n        BEGIN: {\n          enter: function () {\n            self.start();\n            self.tapsCount = 0;\n            self.emit('tappingstart', self, self.gameObject, self.lastPointer);\n          }\n        },\n        RECOGNIZED: {\n          enter: function () {\n            self.start();\n            self.emit('tap', self, self.gameObject, self.lastPointer);\n            self.emit(`${self.tapsCount}tap`, self, self.gameObject, self.lastPointer);\n          }\n        }\n      },\n      init: function () {\n        this.state = IDLE;\n      },\n      eventEmitter: false\n    };\n    this.setRecongizedStateObject(new FSM(stateConfig));\n  }\n\n  resetFromJSON(o) {\n    super.resetFromJSON(o);\n    this.setMaxHoldTime(GetValue(o, 'time', 250)); // min-hold-time of Press is 251\n\n    this.setTapInterval(GetValue(o, 'tapInterval', 200));\n    this.setDragThreshold(GetValue(o, 'threshold', 9));\n    this.setTapOffset(GetValue(o, 'tapOffset', 10));\n    var taps = GetValue(o, 'taps', undefined);\n\n    if (taps !== undefined) {\n      this.setTaps(taps);\n    } else {\n      this.setMaxTaps(GetValue(o, 'maxTaps', undefined));\n      this.setMinTaps(GetValue(o, 'minTaps', undefined));\n    }\n\n    return this;\n  }\n\n  onDragStart() {\n    switch (this.state) {\n      case IDLE:\n        this.state = BEGIN;\n        break;\n\n      case BEGIN:\n        var pointer = this.lastPointer;\n        var tapsOffset = DistanceBetween(pointer.upX, pointer.upY, pointer.x, pointer.y);\n\n        if (tapsOffset > this.tapOffset) {\n          // Can't recognize next level, restart here\n          this.state = RECOGNIZED;\n          this.state = BEGIN;\n        }\n\n        break;\n\n      case RECOGNIZED:\n        this.state = BEGIN;\n        break;\n    }\n  }\n\n  onDragEnd() {\n    if (this.state === BEGIN) {\n      this.tapsCount++; // Try recognize next level\n\n      this.emit('tapping', this, this.gameObject, this.lastPointer);\n\n      if (this.maxTaps !== undefined && this.tapsCount === this.maxTaps) {\n        // Reach to maxTaps, stop here                \n        this.state = RECOGNIZED;\n      }\n    }\n  }\n\n  onDrag() {\n    if (this.state === IDLE) {\n      return;\n    }\n\n    if (this.pointer.getDistance() > this.dragThreshold) {\n      // Cancel\n      this.state = IDLE;\n    }\n  }\n\n  preUpdate(time, delta) {\n    if (this.state === BEGIN) {\n      var pointer = this.lastPointer;\n\n      if (pointer.isDown) {\n        var holdTime = time - pointer.downTime;\n\n        if (holdTime > this.holdTime) {\n          this.state = IDLE;\n        }\n      } else {\n        // isUp\n        var releasedTime = time - pointer.upTime;\n\n        if (releasedTime > this.tapInterval) {\n          if (this.minTaps === undefined || this.tapsCount >= this.minTaps) {\n            this.state = RECOGNIZED;\n          } else {\n            this.state = IDLE;\n          }\n        }\n      }\n    }\n  }\n\n  postUpdate(time, delta) {\n    // Clear RECOGNIZED after update()\n    if (this.state === RECOGNIZED) {\n      this.state = IDLE;\n    }\n  }\n\n  get isTapped() {\n    return this.state === RECOGNIZED;\n  }\n\n  setMaxHoldTime(time) {\n    this.holdTime = time; // ms\n\n    return this;\n  }\n\n  setTapInterval(time) {\n    this.tapInterval = time; // ms\n\n    return this;\n  }\n\n  setDragThreshold(distance) {\n    this.dragThreshold = distance;\n    return this;\n  }\n\n  setTapOffset(distance) {\n    this.tapOffset = distance;\n    return this;\n  }\n\n  setMaxTaps(taps) {\n    this.maxTaps = taps;\n    return this;\n  }\n\n  setMinTaps(taps) {\n    this.minTaps = taps;\n    return this;\n  }\n\n  setTaps(minTaps, maxTaps) {\n    if (maxTaps === undefined) {\n      maxTaps = minTaps;\n    }\n\n    this.setMinTaps(minTaps).setMaxTaps(maxTaps);\n    return this;\n  }\n\n}\n\nconst IDLE = 'IDLE';\nconst BEGIN = 'BEGIN';\nconst RECOGNIZED = 'RECOGNIZED';\nexport default Tap;","map":{"version":3,"sources":["/home/jon/code/Projects/Soulys/frontend/node_modules/phaser3-rex-plugins/plugins/input/gestures/tap/Tap.js"],"names":["OnePointerTracer","FSM","GetValue","Phaser","Utils","Objects","DistanceBetween","Math","Distance","Between","Tap","constructor","gameObject","config","self","stateConfig","states","IDLE","enter","stop","tapsCount","x","y","worldX","worldY","exit","pointer","lastPointer","BEGIN","start","emit","RECOGNIZED","init","state","eventEmitter","setRecongizedStateObject","resetFromJSON","o","setMaxHoldTime","setTapInterval","setDragThreshold","setTapOffset","taps","undefined","setTaps","setMaxTaps","setMinTaps","onDragStart","tapsOffset","upX","upY","tapOffset","onDragEnd","maxTaps","onDrag","getDistance","dragThreshold","preUpdate","time","delta","isDown","holdTime","downTime","releasedTime","upTime","tapInterval","minTaps","postUpdate","isTapped","distance"],"mappings":"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","sourcesContent":["import OnePointerTracer from \"../onepointertracer/OnePointerTracer.js\";\r\nimport FSM from '../../../fsm.js';\r\n\r\nconst GetValue = Phaser.Utils.Objects.GetValue;\r\nconst DistanceBetween = Phaser.Math.Distance.Between;\r\n\r\nclass Tap extends OnePointerTracer {\r\n    constructor(gameObject, config) {\r\n        super(gameObject, config);\r\n\r\n        var self = this;\r\n        var stateConfig = {\r\n            states: {\r\n                IDLE: {\r\n                    enter: function () {\r\n                        self.stop();\r\n                        self.tapsCount = 0;\r\n                        self.x = 0;\r\n                        self.y = 0;\r\n                        self.worldX = 0;\r\n                        self.worldY = 0;\r\n                    },\r\n                    exit: function () {\r\n                        var pointer = self.lastPointer;\r\n                        self.x = pointer.x;\r\n                        self.y = pointer.y;\r\n                        self.worldX = pointer.worldX;\r\n                        self.worldY = pointer.worldY;\r\n                    }\r\n                },\r\n                BEGIN: {\r\n                    enter: function () {\r\n                        self.start();\r\n                        self.tapsCount = 0;\r\n                        self.emit('tappingstart', self, self.gameObject, self.lastPointer);\r\n                    },\r\n                },\r\n                RECOGNIZED: {\r\n                    enter: function () {\r\n                        self.start();\r\n                        self.emit('tap', self, self.gameObject, self.lastPointer);\r\n                        self.emit(`${self.tapsCount}tap`, self, self.gameObject, self.lastPointer);\r\n                    },\r\n                }\r\n            },\r\n            init: function () {\r\n                this.state = IDLE;\r\n            },\r\n            eventEmitter: false,\r\n        }\r\n        this.setRecongizedStateObject(new FSM(stateConfig));\r\n    }\r\n\r\n    resetFromJSON(o) {\r\n        super.resetFromJSON(o);\r\n        this.setMaxHoldTime(GetValue(o, 'time', 250)); // min-hold-time of Press is 251\r\n        this.setTapInterval(GetValue(o, 'tapInterval', 200));\r\n        this.setDragThreshold(GetValue(o, 'threshold', 9));\r\n        this.setTapOffset(GetValue(o, 'tapOffset', 10));\r\n\r\n        var taps = GetValue(o, 'taps', undefined);\r\n        if (taps !== undefined) {\r\n            this.setTaps(taps);\r\n        } else {\r\n            this.setMaxTaps(GetValue(o, 'maxTaps', undefined));\r\n            this.setMinTaps(GetValue(o, 'minTaps', undefined));\r\n        }\r\n        return this;\r\n    }\r\n\r\n    onDragStart() {\r\n        switch (this.state) {\r\n            case IDLE:\r\n                this.state = BEGIN;\r\n                break;\r\n\r\n            case BEGIN:\r\n                var pointer = this.lastPointer;\r\n                var tapsOffset = DistanceBetween(\r\n                    pointer.upX,\r\n                    pointer.upY,\r\n                    pointer.x,\r\n                    pointer.y);\r\n                if (tapsOffset > this.tapOffset) { // Can't recognize next level, restart here\r\n                    this.state = RECOGNIZED;\r\n                    this.state = BEGIN;\r\n                }\r\n                break;\r\n\r\n            case RECOGNIZED:\r\n                this.state = BEGIN;\r\n                break;\r\n        }\r\n    }\r\n\r\n    onDragEnd() {\r\n        if (this.state === BEGIN) {\r\n            this.tapsCount++; // Try recognize next level\r\n            this.emit('tapping', this, this.gameObject, this.lastPointer);\r\n\r\n            if ((this.maxTaps !== undefined) && (this.tapsCount === this.maxTaps)) { // Reach to maxTaps, stop here                \r\n                this.state = RECOGNIZED;\r\n            }\r\n        }\r\n    }\r\n\r\n    onDrag() {\r\n        if (this.state === IDLE) {\r\n            return;\r\n        }\r\n\r\n        if (this.pointer.getDistance() > this.dragThreshold) { // Cancel\r\n            this.state = IDLE;\r\n        }\r\n    }\r\n\r\n    preUpdate(time, delta) {\r\n        if (this.state === BEGIN) {\r\n            var pointer = this.lastPointer;\r\n            if (pointer.isDown) {\r\n                var holdTime = time - pointer.downTime;\r\n                if (holdTime > this.holdTime) {\r\n                    this.state = IDLE;\r\n                }\r\n            } else { // isUp\r\n                var releasedTime = time - pointer.upTime;\r\n                if (releasedTime > this.tapInterval) {\r\n                    if ((this.minTaps === undefined) || (this.tapsCount >= this.minTaps)) {\r\n                        this.state = RECOGNIZED;\r\n                    } else {\r\n                        this.state = IDLE;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    postUpdate(time, delta) {\r\n        // Clear RECOGNIZED after update()\r\n        if (this.state === RECOGNIZED) {\r\n            this.state = IDLE;\r\n        }\r\n    }\r\n\r\n    get isTapped() {\r\n        return (this.state === RECOGNIZED);\r\n    }\r\n\r\n    setMaxHoldTime(time) {\r\n        this.holdTime = time; // ms\r\n        return this;\r\n    }\r\n\r\n    setTapInterval(time) {\r\n        this.tapInterval = time; // ms\r\n        return this;\r\n    }\r\n\r\n    setDragThreshold(distance) {\r\n        this.dragThreshold = distance;\r\n        return this;\r\n    }\r\n\r\n    setTapOffset(distance) {\r\n        this.tapOffset = distance;\r\n        return this;\r\n    }\r\n\r\n    setMaxTaps(taps) {\r\n        this.maxTaps = taps;\r\n        return this;\r\n    }\r\n\r\n    setMinTaps(taps) {\r\n        this.minTaps = taps;\r\n        return this;\r\n    }\r\n\r\n    setTaps(minTaps, maxTaps) {\r\n        if (maxTaps === undefined) {\r\n            maxTaps = minTaps;\r\n        }\r\n        this.setMinTaps(minTaps).setMaxTaps(maxTaps);\r\n        return this;\r\n    }\r\n}\r\n\r\nconst IDLE = 'IDLE';\r\nconst BEGIN = 'BEGIN';\r\nconst RECOGNIZED = 'RECOGNIZED';\r\n\r\nexport default Tap;"]},"metadata":{},"sourceType":"module"}