{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\nimport MeasureText from './MeasureText.js';\nimport CONST from '../const.js';\nconst GetAdvancedValue = Phaser.Utils.Objects.GetAdvancedValue;\nconst GetValue = Phaser.Utils.Objects.GetValue; //  Key: [ Object Key, Default Value ]\n\n/**\r\n * A custom function that will be responsible for wrapping the text.\r\n * @callback TextStyleWordWrapCallback\r\n *\r\n * @param {string} text - The string to wrap.\r\n * @param {Phaser.GameObjects.Text} textObject - The Text instance.\r\n *\r\n * @return {(string|string[])} Should return the wrapped lines either as an array of lines or as a string with\r\n * newline characters in place to indicate where breaks should happen.\r\n */\n\nvar propertyMap = {\n  // background\n  backgroundColor: ['backgroundColor', null],\n  // font\n  fontFamily: ['fontFamily', 'Courier'],\n  fontSize: ['fontSize', '16px'],\n  fontStyle: ['fontStyle', ''],\n  color: ['color', '#fff'],\n  stroke: ['stroke', '#fff'],\n  strokeThickness: ['strokeThickness', 0],\n  shadowOffsetX: ['shadow.offsetX', 0],\n  shadowOffsetY: ['shadow.offsetY', 0],\n  shadowColor: ['shadow.color', '#000'],\n  shadowBlur: ['shadow.blur', 0],\n  shadowStroke: ['shadow.stroke', false],\n  shadowFill: ['shadow.fill', false],\n  // underline\n  underlineColor: ['underline.color', '#000'],\n  underlineThickness: ['underline.thickness', 0],\n  underlineOffset: ['underline.offset', 0],\n  // align\n  halign: ['halign', 'left'],\n  valign: ['valign', 'top'],\n  // size\n  maxLines: ['maxLines', 0],\n  fixedWidth: ['fixedWidth', 0],\n  fixedHeight: ['fixedHeight', 0],\n  resolution: ['resolution', 0],\n  lineSpacing: ['lineSpacing', 0],\n  rtl: ['rtl', false],\n  testString: ['testString', '|MÃ‰qgy'],\n  baselineX: ['baselineX', 1.2],\n  baselineY: ['baselineY', 1.4],\n  // wrap\n  wrapMode: ['wrap.mode', 1],\n  wrapWidth: ['wrap.width', 0] //wrapCallback: ['wrap.callback', null],\n  //wrapCallbackScope: ['wrap.callbackScope', null]\n\n};\n\nclass TextStyle {\n  constructor(text, style) {\n    this.parent = text;\n    this.backgroundColor;\n    this.fontFamily;\n    this.fontSize;\n    this.fontStyle;\n    this.color;\n    this.stroke;\n    this.strokeThickness;\n    this.shadowOffsetX;\n    this.shadowOffsetY;\n    this.shadowColor;\n    this.shadowBlur;\n    this.shadowStroke;\n    this.shadowFill;\n    this.underlineColor;\n    this.underlineThickness;\n    this.underlineOffset;\n    this.halign;\n    this.valign;\n    this.maxLines;\n    this.fixedWidth;\n    this.fixedHeight;\n    this.resolution;\n    this.lineSpacing;\n    this.rtl;\n    this.testString;\n    this.baselineX;\n    this.baselineY;\n    this._font; //  Set to defaults + user style\n\n    this.setStyle(style, false);\n    var metrics = GetValue(style, 'metrics', false); //  Provide optional TextMetrics in the style object to avoid the canvas look-up / scanning\n    //  Doing this is reset if you then change the font of this TextStyle after creation\n\n    if (metrics) {\n      this.metrics = {\n        ascent: GetValue(metrics, 'ascent', 0),\n        descent: GetValue(metrics, 'descent', 0),\n        fontSize: GetValue(metrics, 'fontSize', 0)\n      };\n    } else {\n      this.metrics = MeasureText(this);\n    }\n  }\n\n  setStyle(style, updateText) {\n    if (updateText === undefined) {\n      updateText = true;\n    }\n\n    if (style && style.hasOwnProperty('wrap')) {\n      var wrap = style.wrap;\n\n      if (wrap.hasOwnProperty('mode')) {\n        var mode = wrap.mode;\n\n        if (typeof mode === 'string') {\n          wrap.mode = WRAPMODE[mode];\n        }\n      } else {\n        if (wrap.hasOwnProperty('width')) {\n          wrap.mode = 1;\n        }\n      }\n    } //  Avoid type mutation\n\n\n    if (style && style.hasOwnProperty('fontSize') && typeof style.fontSize === 'number') {\n      style.fontSize = style.fontSize.toString() + 'px';\n    }\n\n    for (var key in propertyMap) {\n      if (key === 'wrapCallback' || key === 'wrapCallbackScope') {\n        // Callback & scope should be set without processing the values\n        this[key] = GetValue(style, propertyMap[key][0], propertyMap[key][1]);\n      } else {\n        this[key] = GetAdvancedValue(style, propertyMap[key][0], propertyMap[key][1]);\n      }\n    } //  Allow for 'font' override\n\n\n    var font = GetValue(style, 'font', null);\n\n    if (font === null) {\n      this._font = this.fontStyle + ' ' + this.fontSize + ' ' + this.fontFamily;\n    } else {\n      this._font = font;\n    } //  Allow for 'fill' to be used in place of 'color'\n\n\n    var fill = GetValue(style, 'fill', null);\n\n    if (fill !== null) {\n      this.color = fill;\n    }\n\n    if (updateText) {\n      return this.update(true);\n    } else {\n      return this.parent;\n    }\n  }\n\n  syncFont(canvas, context) {\n    context.font = this._font;\n  }\n\n  syncStyle(canvas, context) {\n    context.textBaseline = 'alphabetic';\n    context.fillStyle = this.color;\n    context.strokeStyle = this.stroke;\n    context.lineWidth = this.strokeThickness;\n    context.lineCap = 'round';\n    context.lineJoin = 'round';\n  }\n\n  syncShadow(context, enabled) {\n    if (enabled) {\n      context.shadowOffsetX = this.shadowOffsetX;\n      context.shadowOffsetY = this.shadowOffsetY;\n      context.shadowColor = this.shadowColor;\n      context.shadowBlur = this.shadowBlur;\n    } else {\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n      context.shadowColor = 0;\n      context.shadowBlur = 0;\n    }\n  }\n\n  update(recalculateMetrics) {\n    if (recalculateMetrics) {\n      this._font = this.fontStyle + ' ' + this.fontSize + ' ' + this.fontFamily;\n      this.metrics = MeasureText(this);\n    }\n\n    return this.parent.updateText(recalculateMetrics);\n  }\n\n  buildFont() {\n    var newFont = this.fontStyle + ' ' + this.fontSize + ' ' + this.fontFamily;\n\n    if (newFont !== this._font) {\n      this._font = newFont; //this.metrics = MeasureText(this);\n    }\n\n    return this;\n  }\n\n  setFont(font) {\n    if (typeof font === 'string') {\n      this.fontFamily = font;\n      this.fontSize = '';\n      this.fontStyle = '';\n    } else {\n      this.fontFamily = GetValue(font, 'fontFamily', 'Courier');\n      this.fontSize = GetValue(font, 'fontSize', '16px');\n      this.fontStyle = GetValue(font, 'fontStyle', '');\n    }\n\n    return this.update(true);\n  }\n\n  setFontFamily(family) {\n    this.fontFamily = family;\n    return this.update(true);\n  }\n\n  setFontStyle(style) {\n    this.fontStyle = style;\n    return this.update(true);\n  }\n\n  setFontSize(size) {\n    if (typeof size === 'number') {\n      size = size.toString() + 'px';\n    }\n\n    this.fontSize = size;\n    return this.update(true);\n  }\n\n  setTestString(string) {\n    this.testString = string;\n    return this.update(true);\n  }\n\n  setFixedSize(width, height) {\n    this.fixedWidth = width;\n    this.fixedHeight = height;\n\n    if (width) {\n      this.parent.width = width;\n    }\n\n    if (height) {\n      this.parent.height = height;\n    }\n\n    return this.update(false);\n  }\n\n  setResolution(value) {\n    this.resolution = value;\n    return this.update(false);\n  }\n\n  setLineSpacing(value) {\n    this.lineSpacing = value;\n    return this.update(false);\n  }\n\n  setBackgroundColor(color) {\n    this.backgroundColor = color;\n    return this.update(false);\n  }\n\n  setFill(color) {\n    this.color = color;\n    return this.update(false);\n  }\n\n  setColor(color) {\n    this.color = color;\n    return this.update(false);\n  }\n\n  setStroke(color, thickness) {\n    if (color === undefined) {\n      //  Reset the stroke to zero (disabling it)\n      this.strokeThickness = 0;\n    } else {\n      if (thickness === undefined) {\n        thickness = this.strokeThickness;\n      }\n\n      this.stroke = color;\n      this.strokeThickness = thickness;\n    }\n\n    return this.update(true);\n  }\n\n  setShadow(x, y, color, blur, shadowStroke, shadowFill) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (color === undefined) {\n      color = '#000';\n    }\n\n    if (blur === undefined) {\n      blur = 0;\n    }\n\n    if (shadowStroke === undefined) {\n      shadowStroke = false;\n    }\n\n    if (shadowFill === undefined) {\n      shadowFill = true;\n    }\n\n    this.shadowOffsetX = x;\n    this.shadowOffsetY = y;\n    this.shadowColor = color;\n    this.shadowBlur = blur;\n    this.shadowStroke = shadowStroke;\n    this.shadowFill = shadowFill;\n    return this.update(false);\n  }\n\n  setShadowOffset(x, y) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = x;\n    }\n\n    this.shadowOffsetX = x;\n    this.shadowOffsetY = y;\n    return this.update(false);\n  }\n\n  setShadowColor(color) {\n    if (color === undefined) {\n      color = '#000';\n    }\n\n    this.shadowColor = color;\n    return this.update(false);\n  }\n\n  setShadowBlur(blur) {\n    if (blur === undefined) {\n      blur = 0;\n    }\n\n    this.shadowBlur = blur;\n    return this.update(false);\n  }\n\n  setShadowStroke(enabled) {\n    this.shadowStroke = enabled;\n    return this.update(false);\n  }\n\n  setShadowFill(enabled) {\n    this.shadowFill = enabled;\n    return this.update(false);\n  }\n\n  setUnderline(color, thickness, offset) {\n    if (color === undefined) {\n      color = '#000';\n    }\n\n    if (thickness === undefined) {\n      thickness = 0;\n    }\n\n    if (offset === undefined) {\n      offset = 0;\n    }\n\n    this.underlineColor = color;\n    this.underlineThickness = thickness;\n    this.underlineOffset = offset;\n    return this.update(false);\n  }\n\n  setUnderlineColor(color) {\n    if (color === undefined) {\n      color = '#000';\n    }\n\n    this.underlineColor = color;\n    return this.update(false);\n  }\n\n  setUnderlineThickness(thickness) {\n    if (thickness === undefined) {\n      thickness = 0;\n    }\n\n    this.underlineThickness = thickness;\n    return this.update(false);\n  }\n\n  setUnderlineOffset(offset) {\n    if (offset === undefined) {\n      offset = 0;\n    }\n\n    this.underlineOffset = offset;\n    return this.update(false);\n  }\n\n  setWrapMode(mode) {\n    if (typeof mode === 'string') {\n      mode = WRAPMODE[mode.toLowerCase()] || 0;\n    }\n\n    this.wrapMode = mode;\n    return this.update(true);\n  }\n\n  setWrapWidth(width) {\n    this.wrapWidth = width;\n    return this.update(false);\n  }\n\n  setAlign(halign, valign) {\n    if (halign === undefined) {\n      halign = 'left';\n    }\n\n    if (valign === undefined) {\n      valign = 'top';\n    }\n\n    this.halign = halign;\n    this.valign = valign;\n    return this.update(false);\n  }\n\n  setHAlign(halign) {\n    if (halign === undefined) {\n      halign = 'left';\n    }\n\n    this.halign = halign;\n    return this.update(false);\n  }\n\n  setVAlign(valign) {\n    if (valign === undefined) {\n      valign = 'top';\n    }\n\n    this.valign = valign;\n    return this.update(false);\n  }\n\n  setMaxLines(max) {\n    if (max === undefined) {\n      max = 0;\n    }\n\n    this.maxLines = max;\n    return this.update(false);\n  }\n\n  getTextMetrics() {\n    var metrics = this.metrics;\n    return {\n      ascent: metrics.ascent,\n      descent: metrics.descent,\n      fontSize: metrics.fontSize\n    };\n  }\n\n  get lineHeight() {\n    return this.metrics.fontSize + this.strokeThickness + this.lineSpacing;\n  }\n\n  toJSON() {\n    var output = {};\n\n    for (var key in propertyMap) {\n      output[key] = this[key];\n    }\n\n    output.metrics = this.getTextMetrics();\n    return output;\n  }\n\n  destroy() {\n    this.parent = undefined;\n  }\n\n}\n\nconst HALIGNMODE = {\n  left: CONST.hleft,\n  center: CONST.hcenter,\n  right: CONST.hright\n};\nconst VALIGNMODE = {\n  top: CONST.vtop,\n  center: CONST.vcenter,\n  bottom: CONST.vbottom\n};\nconst WRAPMODE = {\n  none: CONST.NO_WRAP,\n  word: CONST.WORD_WRAP,\n  char: CONST.CHAR_WRAP,\n  character: CONST.CHAR_WRAP\n};\nexport default TextStyle;","map":{"version":3,"sources":["/home/jon/code/Projects/Soulys/frontend/node_modules/phaser3-rex-plugins/plugins/gameobjects/text/textbase/textstyle/TextStyle.js"],"names":["MeasureText","CONST","GetAdvancedValue","Phaser","Utils","Objects","GetValue","propertyMap","backgroundColor","fontFamily","fontSize","fontStyle","color","stroke","strokeThickness","shadowOffsetX","shadowOffsetY","shadowColor","shadowBlur","shadowStroke","shadowFill","underlineColor","underlineThickness","underlineOffset","halign","valign","maxLines","fixedWidth","fixedHeight","resolution","lineSpacing","rtl","testString","baselineX","baselineY","wrapMode","wrapWidth","TextStyle","constructor","text","style","parent","_font","setStyle","metrics","ascent","descent","updateText","undefined","hasOwnProperty","wrap","mode","WRAPMODE","toString","key","font","fill","update","syncFont","canvas","context","syncStyle","textBaseline","fillStyle","strokeStyle","lineWidth","lineCap","lineJoin","syncShadow","enabled","recalculateMetrics","buildFont","newFont","setFont","setFontFamily","family","setFontStyle","setFontSize","size","setTestString","string","setFixedSize","width","height","setResolution","value","setLineSpacing","setBackgroundColor","setFill","setColor","setStroke","thickness","setShadow","x","y","blur","setShadowOffset","setShadowColor","setShadowBlur","setShadowStroke","setShadowFill","setUnderline","offset","setUnderlineColor","setUnderlineThickness","setUnderlineOffset","setWrapMode","toLowerCase","setWrapWidth","setAlign","setHAlign","setVAlign","setMaxLines","max","getTextMetrics","lineHeight","toJSON","output","destroy","HALIGNMODE","left","hleft","center","hcenter","right","hright","VALIGNMODE","top","vtop","vcenter","bottom","vbottom","none","NO_WRAP","word","WORD_WRAP","char","CHAR_WRAP","character"],"mappings":"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","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nimport MeasureText from './MeasureText.js';\r\nimport CONST from '../const.js';\r\n\r\nconst GetAdvancedValue = Phaser.Utils.Objects.GetAdvancedValue;\r\nconst GetValue = Phaser.Utils.Objects.GetValue;\r\n\r\n//  Key: [ Object Key, Default Value ]\r\n\r\n/**\r\n * A custom function that will be responsible for wrapping the text.\r\n * @callback TextStyleWordWrapCallback\r\n *\r\n * @param {string} text - The string to wrap.\r\n * @param {Phaser.GameObjects.Text} textObject - The Text instance.\r\n *\r\n * @return {(string|string[])} Should return the wrapped lines either as an array of lines or as a string with\r\n * newline characters in place to indicate where breaks should happen.\r\n */\r\n\r\nvar propertyMap = {\r\n    // background\r\n    backgroundColor: ['backgroundColor', null],\r\n\r\n    // font\r\n    fontFamily: ['fontFamily', 'Courier'],\r\n    fontSize: ['fontSize', '16px'],\r\n    fontStyle: ['fontStyle', ''],\r\n    color: ['color', '#fff'],\r\n    stroke: ['stroke', '#fff'],\r\n    strokeThickness: ['strokeThickness', 0],\r\n    shadowOffsetX: ['shadow.offsetX', 0],\r\n    shadowOffsetY: ['shadow.offsetY', 0],\r\n    shadowColor: ['shadow.color', '#000'],\r\n    shadowBlur: ['shadow.blur', 0],\r\n    shadowStroke: ['shadow.stroke', false],\r\n    shadowFill: ['shadow.fill', false],\r\n\r\n    // underline\r\n    underlineColor: ['underline.color', '#000'],\r\n    underlineThickness: ['underline.thickness', 0],\r\n    underlineOffset: ['underline.offset', 0],\r\n\r\n    // align\r\n    halign: ['halign', 'left'],\r\n    valign: ['valign', 'top'],\r\n\r\n    // size\r\n    maxLines: ['maxLines', 0],\r\n    fixedWidth: ['fixedWidth', 0],\r\n    fixedHeight: ['fixedHeight', 0],\r\n    resolution: ['resolution', 0],\r\n    lineSpacing: ['lineSpacing', 0],\r\n\r\n    rtl: ['rtl', false],\r\n    testString: ['testString', '|MÃ‰qgy'],\r\n    baselineX: ['baselineX', 1.2],\r\n    baselineY: ['baselineY', 1.4],\r\n\r\n    // wrap\r\n    wrapMode: ['wrap.mode', 1],\r\n    wrapWidth: ['wrap.width', 0]\r\n    //wrapCallback: ['wrap.callback', null],\r\n    //wrapCallbackScope: ['wrap.callbackScope', null]\r\n};\r\n\r\nclass TextStyle {\r\n    constructor(text, style) {\r\n        this.parent = text;\r\n\r\n        this.backgroundColor;\r\n\r\n        this.fontFamily;\r\n        this.fontSize;\r\n        this.fontStyle;\r\n        this.color;\r\n        this.stroke;\r\n        this.strokeThickness;\r\n        this.shadowOffsetX;\r\n        this.shadowOffsetY;\r\n        this.shadowColor;\r\n        this.shadowBlur;\r\n        this.shadowStroke;\r\n        this.shadowFill;\r\n\r\n        this.underlineColor;\r\n        this.underlineThickness;\r\n        this.underlineOffset;\r\n\r\n        this.halign;\r\n        this.valign;\r\n\r\n        this.maxLines;\r\n        this.fixedWidth;\r\n        this.fixedHeight;\r\n        this.resolution;\r\n        this.lineSpacing;\r\n\r\n        this.rtl;\r\n        this.testString;\r\n\r\n\r\n        this.baselineX;\r\n        this.baselineY;\r\n\r\n        this._font;\r\n\r\n        //  Set to defaults + user style\r\n        this.setStyle(style, false);\r\n\r\n        var metrics = GetValue(style, 'metrics', false);\r\n\r\n        //  Provide optional TextMetrics in the style object to avoid the canvas look-up / scanning\r\n        //  Doing this is reset if you then change the font of this TextStyle after creation\r\n        if (metrics) {\r\n            this.metrics = {\r\n                ascent: GetValue(metrics, 'ascent', 0),\r\n                descent: GetValue(metrics, 'descent', 0),\r\n                fontSize: GetValue(metrics, 'fontSize', 0)\r\n            };\r\n        } else {\r\n            this.metrics = MeasureText(this);\r\n        }\r\n    }\r\n\r\n    setStyle(style, updateText) {\r\n        if (updateText === undefined) {\r\n            updateText = true;\r\n        }\r\n\r\n        if (style && style.hasOwnProperty('wrap')) {\r\n            var wrap = style.wrap;\r\n            if (wrap.hasOwnProperty('mode')) {\r\n                var mode = wrap.mode;\r\n                if (typeof mode === 'string') {\r\n                    wrap.mode = WRAPMODE[mode];\r\n                }\r\n            } else {\r\n                if (wrap.hasOwnProperty('width')) {\r\n                    wrap.mode = 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        //  Avoid type mutation\r\n        if (style && style.hasOwnProperty('fontSize') && typeof style.fontSize === 'number') {\r\n            style.fontSize = style.fontSize.toString() + 'px';\r\n        }\r\n\r\n        for (var key in propertyMap) {\r\n            if (key === 'wrapCallback' || key === 'wrapCallbackScope') {\r\n                // Callback & scope should be set without processing the values\r\n                this[key] = GetValue(style, propertyMap[key][0], propertyMap[key][1]);\r\n            } else {\r\n                this[key] = GetAdvancedValue(style, propertyMap[key][0], propertyMap[key][1]);\r\n            }\r\n        }\r\n\r\n        //  Allow for 'font' override\r\n        var font = GetValue(style, 'font', null);\r\n\r\n        if (font === null) {\r\n            this._font = this.fontStyle + ' ' + this.fontSize + ' ' + this.fontFamily;\r\n        } else {\r\n            this._font = font;\r\n        }\r\n\r\n        //  Allow for 'fill' to be used in place of 'color'\r\n        var fill = GetValue(style, 'fill', null);\r\n\r\n        if (fill !== null) {\r\n            this.color = fill;\r\n        }\r\n\r\n        if (updateText) {\r\n            return this.update(true);\r\n        } else {\r\n            return this.parent;\r\n        }\r\n    }\r\n\r\n    syncFont(canvas, context) {\r\n        context.font = this._font;\r\n    }\r\n\r\n    syncStyle(canvas, context) {\r\n        context.textBaseline = 'alphabetic';\r\n\r\n        context.fillStyle = this.color;\r\n        context.strokeStyle = this.stroke;\r\n\r\n        context.lineWidth = this.strokeThickness;\r\n        context.lineCap = 'round';\r\n        context.lineJoin = 'round';\r\n    }\r\n\r\n    syncShadow(context, enabled) {\r\n        if (enabled) {\r\n            context.shadowOffsetX = this.shadowOffsetX;\r\n            context.shadowOffsetY = this.shadowOffsetY;\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n        } else {\r\n            context.shadowOffsetX = 0;\r\n            context.shadowOffsetY = 0;\r\n            context.shadowColor = 0;\r\n            context.shadowBlur = 0;\r\n        }\r\n    }\r\n\r\n    update(recalculateMetrics) {\r\n        if (recalculateMetrics) {\r\n            this._font = this.fontStyle + ' ' + this.fontSize + ' ' + this.fontFamily;\r\n\r\n            this.metrics = MeasureText(this);\r\n        }\r\n\r\n        return this.parent.updateText(recalculateMetrics);\r\n    }\r\n\r\n    buildFont() {\r\n        var newFont = this.fontStyle + ' ' + this.fontSize + ' ' + this.fontFamily;\r\n        if (newFont !== this._font) {\r\n            this._font = newFont;\r\n            //this.metrics = MeasureText(this);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    setFont(font) {\r\n        if (typeof font === 'string') {\r\n            this.fontFamily = font;\r\n            this.fontSize = '';\r\n            this.fontStyle = '';\r\n        } else {\r\n            this.fontFamily = GetValue(font, 'fontFamily', 'Courier');\r\n            this.fontSize = GetValue(font, 'fontSize', '16px');\r\n            this.fontStyle = GetValue(font, 'fontStyle', '');\r\n        }\r\n\r\n        return this.update(true);\r\n    }\r\n\r\n    setFontFamily(family) {\r\n        this.fontFamily = family;\r\n\r\n        return this.update(true);\r\n    }\r\n\r\n    setFontStyle(style) {\r\n        this.fontStyle = style;\r\n\r\n        return this.update(true);\r\n    }\r\n\r\n    setFontSize(size) {\r\n        if (typeof size === 'number') {\r\n            size = size.toString() + 'px';\r\n        }\r\n\r\n        this.fontSize = size;\r\n\r\n        return this.update(true);\r\n    }\r\n\r\n    setTestString(string) {\r\n        this.testString = string;\r\n\r\n        return this.update(true);\r\n    }\r\n\r\n    setFixedSize(width, height) {\r\n        this.fixedWidth = width;\r\n        this.fixedHeight = height;\r\n\r\n        if (width) {\r\n            this.parent.width = width;\r\n        }\r\n\r\n        if (height) {\r\n            this.parent.height = height;\r\n        }\r\n\r\n        return this.update(false);\r\n    }\r\n\r\n    setResolution(value) {\r\n        this.resolution = value;\r\n\r\n        return this.update(false);\r\n    }\r\n\r\n    setLineSpacing(value) {\r\n        this.lineSpacing = value;\r\n\r\n        return this.update(false);\r\n    }\r\n\r\n    setBackgroundColor(color) {\r\n        this.backgroundColor = color;\r\n\r\n        return this.update(false);\r\n    }\r\n\r\n    setFill(color) {\r\n        this.color = color;\r\n\r\n        return this.update(false);\r\n    }\r\n\r\n    setColor(color) {\r\n        this.color = color;\r\n\r\n        return this.update(false);\r\n    }\r\n\r\n    setStroke(color, thickness) {\r\n        if (color === undefined) {\r\n            //  Reset the stroke to zero (disabling it)\r\n            this.strokeThickness = 0;\r\n        } else {\r\n            if (thickness === undefined) {\r\n                thickness = this.strokeThickness;\r\n            }\r\n\r\n            this.stroke = color;\r\n            this.strokeThickness = thickness;\r\n        }\r\n\r\n        return this.update(true);\r\n    }\r\n\r\n    setShadow(x, y, color, blur, shadowStroke, shadowFill) {\r\n        if (x === undefined) {\r\n            x = 0;\r\n        }\r\n        if (y === undefined) {\r\n            y = 0;\r\n        }\r\n        if (color === undefined) {\r\n            color = '#000';\r\n        }\r\n        if (blur === undefined) {\r\n            blur = 0;\r\n        }\r\n        if (shadowStroke === undefined) {\r\n            shadowStroke = false;\r\n        }\r\n        if (shadowFill === undefined) {\r\n            shadowFill = true;\r\n        }\r\n\r\n        this.shadowOffsetX = x;\r\n        this.shadowOffsetY = y;\r\n        this.shadowColor = color;\r\n        this.shadowBlur = blur;\r\n        this.shadowStroke = shadowStroke;\r\n        this.shadowFill = shadowFill;\r\n\r\n        return this.update(false);\r\n    }\r\n\r\n    setShadowOffset(x, y) {\r\n        if (x === undefined) {\r\n            x = 0;\r\n        }\r\n        if (y === undefined) {\r\n            y = x;\r\n        }\r\n\r\n        this.shadowOffsetX = x;\r\n        this.shadowOffsetY = y;\r\n\r\n        return this.update(false);\r\n    }\r\n\r\n    setShadowColor(color) {\r\n        if (color === undefined) {\r\n            color = '#000';\r\n        }\r\n\r\n        this.shadowColor = color;\r\n\r\n        return this.update(false);\r\n    }\r\n\r\n    setShadowBlur(blur) {\r\n        if (blur === undefined) {\r\n            blur = 0;\r\n        }\r\n\r\n        this.shadowBlur = blur;\r\n\r\n        return this.update(false);\r\n    }\r\n\r\n    setShadowStroke(enabled) {\r\n        this.shadowStroke = enabled;\r\n\r\n        return this.update(false);\r\n    }\r\n\r\n    setShadowFill(enabled) {\r\n        this.shadowFill = enabled;\r\n\r\n        return this.update(false);\r\n    }\r\n\r\n    setUnderline(color, thickness, offset) {\r\n        if (color === undefined) {\r\n            color = '#000';\r\n        }\r\n        if (thickness === undefined) {\r\n            thickness = 0;\r\n        }\r\n        if (offset === undefined) {\r\n            offset = 0;\r\n        }\r\n\r\n        this.underlineColor = color;\r\n        this.underlineThickness = thickness;\r\n        this.underlineOffset = offset;\r\n\r\n        return this.update(false);\r\n    }\r\n\r\n    setUnderlineColor(color) {\r\n        if (color === undefined) {\r\n            color = '#000';\r\n        }\r\n\r\n        this.underlineColor = color;\r\n        return this.update(false);\r\n    }\r\n\r\n    setUnderlineThickness(thickness) {\r\n        if (thickness === undefined) {\r\n            thickness = 0;\r\n        }\r\n\r\n        this.underlineThickness = thickness;\r\n        return this.update(false);\r\n    }\r\n\r\n    setUnderlineOffset(offset) {\r\n        if (offset === undefined) {\r\n            offset = 0;\r\n        }\r\n\r\n        this.underlineOffset = offset;\r\n        return this.update(false);\r\n    }\r\n\r\n    setWrapMode(mode) {\r\n        if (typeof mode === 'string') {\r\n            mode = WRAPMODE[mode.toLowerCase()] || 0;\r\n        }\r\n        this.wrapMode = mode;\r\n        return this.update(true);\r\n    }\r\n\r\n    setWrapWidth(width) {\r\n        this.wrapWidth = width;\r\n        return this.update(false);\r\n    }\r\n\r\n    setAlign(halign, valign) {\r\n        if (halign === undefined) {\r\n            halign = 'left';\r\n        }\r\n        if (valign === undefined) {\r\n            valign = 'top';\r\n        }\r\n        this.halign = halign;\r\n        this.valign = valign;\r\n\r\n        return this.update(false);\r\n    }\r\n\r\n    setHAlign(halign) {\r\n        if (halign === undefined) {\r\n            halign = 'left';\r\n        }\r\n        this.halign = halign;\r\n\r\n        return this.update(false);\r\n    }\r\n\r\n    setVAlign(valign) {\r\n        if (valign === undefined) {\r\n            valign = 'top';\r\n        }\r\n        this.valign = valign;\r\n\r\n        return this.update(false);\r\n    }\r\n\r\n    setMaxLines(max) {\r\n        if (max === undefined) {\r\n            max = 0;\r\n        }\r\n\r\n        this.maxLines = max;\r\n\r\n        return this.update(false);\r\n    }\r\n\r\n    getTextMetrics() {\r\n        var metrics = this.metrics;\r\n\r\n        return {\r\n            ascent: metrics.ascent,\r\n            descent: metrics.descent,\r\n            fontSize: metrics.fontSize\r\n        };\r\n    }\r\n\r\n    get lineHeight() {\r\n        return this.metrics.fontSize + this.strokeThickness + this.lineSpacing;\r\n    }\r\n\r\n    toJSON() {\r\n        var output = {};\r\n\r\n        for (var key in propertyMap) {\r\n            output[key] = this[key];\r\n        }\r\n\r\n        output.metrics = this.getTextMetrics();\r\n\r\n        return output;\r\n    }\r\n\r\n    destroy() {\r\n        this.parent = undefined;\r\n    }\r\n\r\n}\r\n\r\nconst HALIGNMODE = {\r\n    left: CONST.hleft,\r\n    center: CONST.hcenter,\r\n    right: CONST.hright,\r\n};\r\nconst VALIGNMODE = {\r\n    top: CONST.vtop,\r\n    center: CONST.vcenter,\r\n    bottom: CONST.vbottom,\r\n};\r\nconst WRAPMODE = {\r\n    none: CONST.NO_WRAP,\r\n    word: CONST.WORD_WRAP,\r\n    char: CONST.CHAR_WRAP,\r\n    character: CONST.CHAR_WRAP\r\n};\r\n\r\nexport default TextStyle;"]},"metadata":{},"sourceType":"module"}